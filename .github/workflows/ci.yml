name: CI with SonarQube and Docker

on:
  push:
    branches: [ "main", "master", "docker" ]
  pull_request:
    branches: [ "main", "master", "docker" ]

permissions:
  contents: read
  pull-requests: read
  security-events: write

env:
  REGISTRY: docker.io
  FRONTEND_IMAGE: anupsharma329/frontend
  BACKEND_IMAGE: anupsharma329/backend
  SONAR_PROJECT_KEY: anupsharma329_fullstack-react-app

jobs:
  build-and-test:
    name: Build and Test (frontend + backend)
    runs-on: ubuntu-latest
    outputs:
      frontend-version: ${{ steps.version.outputs.frontend-version }}
      backend-version: ${{ steps.version.outputs.backend-version }}
      should-deploy: ${{ steps.check-branch.outputs.should-deploy }}
    strategy:
      matrix:
        project: [ frontend, backend ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Semantic Versioning
        id: version
        uses: paulhatch/semantic-version@v5.3.0
        with:
          tag_prefix: ""
          major_pattern: "BREAKING CHANGE:"
          minor_pattern: "feat:"
          format: "${major}.${minor}.${patch}-${increment}"

      - name: Check if should deploy
        id: check-branch
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/master" || "${{ github.ref }}" == "refs/heads/docker" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Use Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: 18
          cache: 'npm'
          cache-dependency-path: |
            ${{ matrix.project }}/package-lock.json

      - name: Install dependencies
        working-directory: ${{ matrix.project }}
        run: npm ci

      - name: Run tests with coverage
        working-directory: ${{ matrix.project }}
        run: |
          npm run test --if-present -- --watch=false --ci --coverage --passWithNoTests || true

      - name: Build (if present)
        working-directory: ${{ matrix.project }}
        run: npm run build --if-present

      - name: Display versions
        run: |
          echo "Frontend Version: ${{ steps.version.outputs.version }}"
          echo "Backend Version: ${{ steps.version.outputs.version }}"
          echo "Semantic Version: ${{ steps.version.outputs.semantic_version }}"
          echo "Branch: ${{ github.ref }}"

  sonar-analysis:
    name: SonarQube Analysis
    needs: [ build-and-test ]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Use Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v2
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >-
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.projectKey=${{ env.SONAR_PROJECT_KEY }}
            -Dsonar.sources=frontend/src,backend
            -Dsonar.exclusions=**/node_modules/**,**/*.test.js,**/*.spec.js,frontend/build/**,backend/node_modules/**
            -Dsonar.sourceEncoding=UTF-8
            -Dsonar.javascript.lcov.reportPaths=frontend/coverage/lcov.info,backend/coverage/lcov.info
            -Dsonar.coverage.exclusions=**/node_modules/**,**/*.test.js,**/*.spec.js
            -Dsonar.ci.autoconfig.disabled=true
            ${{ github.event_name == 'pull_request' && format('-Dsonar.pullrequest.key={0} -Dsonar.pullrequest.branch={1} -Dsonar.pullrequest.base={2}', github.event.pull_request.number, github.event.pull_request.head.ref, github.event.pull_request.base.ref) || '' }}

      - name: SonarQube Quality Gate Check
        if: github.event_name == 'push'
        uses: SonarSource/sonarqube-quality-gate-action@v1.1.0
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Upload frontend build
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/build
          if-no-files-found: ignore

      - name: Upload backend package
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: backend-src
          path: backend
          if-no-files-found: ignore

  build-and-push-docker:
    name: Build and Push Docker Images
    needs: [ build-and-test, sonar-analysis ]
    if: needs.build-and-test.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.FRONTEND_IMAGE }}
            ${{ env.BACKEND_IMAGE }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Get Semantic Version
        id: version
        uses: paulhatch/semantic-version@v5.3.0
        with:
          tag_prefix: ""
          major_pattern: "BREAKING CHANGE:"
          minor_pattern: "feat:"

      - name: Build and push Frontend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ env.FRONTEND_IMAGE }}:v${{ steps.version.outputs.version }}
            ${{ env.FRONTEND_IMAGE }}:latest
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Backend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}:v${{ steps.version.outputs.version }}
            ${{ env.BACKEND_IMAGE }}:latest
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Output version info
        run: |
          echo "Frontend Image: ${{ env.FRONTEND_IMAGE }}:v${{ steps.version.outputs.version }}"
          echo "Backend Image: ${{ env.BACKEND_IMAGE }}:v${{ steps.version.outputs.version }}"
          echo "Semantic Version: v${{ steps.version.outputs.version }}"

  deploy-to-minikube:
    name: Deploy to Minikube (Local)
    needs: [ build-and-push-docker ]
    if: needs.build-and-test.outputs.should-deploy == 'true' && github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get Semantic Version
        id: version
        uses: paulhatch/semantic-version@v5.3.0
        with:
          tag_prefix: ""
          major_pattern: "BREAKING CHANGE:"
          minor_pattern: "feat:"

      - name: Setup Minikube
        run: |
          curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
          sudo install minikube-linux-amd64 /usr/local/bin/minikube
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          minikube start --driver=docker --force
          minikube addons enable ingress

      - name: Wait for Ingress Controller
        run: |
          echo "Waiting for ingress controller to be ready..."
          # Wait for ingress-nginx namespace
          until kubectl get namespace ingress-nginx >/dev/null 2>&1; do
            sleep 5
          done
          
          # Wait for ingress controller pods
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=180s
          
          # Additional wait for webhook service
          sleep 30

      - name: Update Ingress for Minikube
        run: |
          # Create a temporary ingress file without host for Minikube
          cat > k8s/ingress-minikube.yaml << EOF
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: app-ingress
            namespace: fullstack-app
            annotations:
              nginx.ingress.kubernetes.io/rewrite-target: /$1
              nginx.ingress.kubernetes.io/ssl-redirect: "false"
              nginx.ingress.kubernetes.io/proxy-body-size: "10m"
              nginx.ingress.kubernetes.io/proxy-connect-timeout: "30"
              nginx.ingress.kubernetes.io/proxy-send-timeout: "600"
              nginx.ingress.kubernetes.io/proxy-read-timeout: "600"
              nginx.ingress.kubernetes.io/enable-cors: "true"
              nginx.ingress.kubernetes.io/cors-allow-origin: "*"
              nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, OPTIONS"
              nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization"
          spec:
            ingressClassName: nginx
            rules:
            - http:
                paths:
                - path: /api(/|$)(.*)
                  pathType: Prefix
                  backend:
                    service:
                      name: backend-svc
                      port:
                        number: 5001
                - path: /(.*)
                  pathType: Prefix
                  backend:
                    service:
                      name: frontend-svc
                      port:
                        number: 80
          EOF

      - name: Deploy Application
        run: |
          # Update image versions
          sed -i "s|anupsharma329/frontend:.*|anupsharma329/frontend:v${{ steps.version.outputs.version }}|g" k8s/frontend-deployment.yaml
          sed -i "s|anupsharma329/backend:.*|anupsharma329/backend:v${{ steps.version.outputs.version }}|g" k8s/backend-deployment.yaml
          
          # Apply manifests (use the modified ingress)
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/backend-deployment.yaml
          kubectl apply -f k8s/frontend-deployment.yaml
          kubectl apply -f k8s/ingress-minikube.yaml
          
          # Wait for rollout
          kubectl rollout status deployment/frontend-deployment -n fullstack-app --timeout=300s
          kubectl rollout status deployment/backend-deployment -n fullstack-app --timeout=300s
          
          # Get application URLs
          echo "ğŸ¯ Application deployed successfully!"
          MINIKUBE_IP=$(minikube ip)
          echo "ğŸŒ Minikube IP: $MINIKUBE_IP"
          echo "ğŸ”— Frontend URL: http://$MINIKUBE_IP"
          echo "ğŸ”— Backend API: http://$MINIKUBE_IP/api"
          echo ""
          echo "ğŸ’¡ To test: curl http://$MINIKUBE_IP/api/data"

      - name: Test Application
        run: |
          # Wait for application to be ready
          sleep 30
          
          MINIKUBE_IP=$(minikube ip)
          
          # Test backend API
          echo "Testing backend API..."
          curl -f "http://$MINIKUBE_IP/api/data" || echo "Backend test failed"
          
          # Test frontend
          echo "Testing frontend..."
          curl -f "http://$MINIKUBE_IP" || echo "Frontend test failed"